<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satellite Deorbiting System</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.107.1/Build/Cesium/Cesium.js"></script>
    <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.107.1/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Saira:ital,wght@0,100..900;1,100..900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');

        html,
        body,
        #cesiumContainer {
            font-family: Saira, sans-serif;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #info {
            color: white;
            position: absolute;
            top: 300px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px white;
            padding: 10px;
            border: 1px solid black;
            z-index: 1000;
        }

        #zoom-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: #111;
            box-shadow: 0 0 10px #111;
            padding: 5px;
            border: 1px solid black;
        }

        button {
            margin: 5px;
            padding: 10px;
            background-color: #111;
            border: none;
            box-shadow: 0 0 5px #222;
        }
        
        button i, #resetBtn {
            font-family: "Russo One", sans-serif;
            letter-spacing: 4px;
            font-size: 30px;
            color: white;
        }
        
        button i {
            padding-left: 1px;
        }

        .logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 200px;
            height: auto;
            z-index: 100000;
        }

    </style>
</head>

<body>

    <img src = "logo_Sds.webp" alt = "logo" class = "logo">

    <div id="cesiumContainer"></div>
    <div id="info">
        <h3>Information</h3>
        <p id="object-info">Click on an object to see details.</p>
    </div>
    <div id="zoom-buttons">
        <button id="resetBtn">RESET VIEW</button>
        <button id="zoomInBtn"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
        <button id="zoomOutBtn"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
    </div>

    <script type="module">
        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJkZTRhNWMzZC1iYTNiLTQzOTgtOWI5YS0xYTg3MThiNjcwMTMiLCJpZCI6MjQ0MTA1LCJpYXQiOjE3MjcyODMwNTJ9.-_H_Lof4en96XQPKq4jDO645JhfmIYXE4ctH3CksfT8";

        const viewer = new Cesium.Viewer("cesiumContainer", {
            homeButton: false,
            sceneModePicker: false,
            baseLayerPicker: false,
            fullscreenButton: false,
            vrButton: false,
            infoBox: false,
            selectionIndicator: true,
            timeline: false,
            animation: true,
            navigationHelpButton: false,
            geocoder: false,
            creditContainer: document.createElement('div')
        });

        async function fetchTLEData(url) {
            const response = await fetch(url);
            const text = await response.text();
            const tleLines = text.trim().split('\n');

            const tleData = [];
            for (let i = 0; i < tleLines.length; i += 3) {
                if (tleLines[i + 1] && tleLines[i + 2]) {
                    tleData.push({
                        name: tleLines[i].trim(),
                        tle: [
                            tleLines[i + 1].trim(),
                            tleLines[i + 2].trim()
                        ]
                    });
                }
            }
            return tleData;
        }

        async function fetchAllTLEData() {
            const debrisSources = [
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=cosmos-2251-debris&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=cosmos-1408-debris&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=fengyun-1c-debris&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=iridium-33-debris&FORMAT=tle'
            ];

            const satelliteSources = [
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=stations&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=weather&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=sarsat&FORMAT=tle',
                'https://celestrak.org/NORAD/elements/gp.php?GROUP=geo&FORMAT=tle'
            ];

            let debrisData = [];
            let satelliteData = [];

            for (const url of debrisSources) {
                const data = await fetchTLEData(url);
                debrisData = debrisData.concat(data);
            }

            for (const url of satelliteSources) {
                const data = await fetchTLEData(url);
                satelliteData = satelliteData.concat(data);
            }

            return { debrisData: debrisData.slice(0, 150), satelliteData: satelliteData.slice(0, 150) };
        }

        function addSatellitesAndDebris(tleData, color, type) {
            tleData.forEach((object, index) => {
                const satrec = satellite.twoline2satrec(object.tle[0], object.tle[1]);
                const positionProperty = new Cesium.SampledPositionProperty();

                for (let i = 0; i <= 3600; i += 60) {
                    const time = Cesium.JulianDate.addSeconds(viewer.clock.startTime, i, new Cesium.JulianDate());
                    const positionAndVelocity = satellite.propagate(satrec, Cesium.JulianDate.toDate(time));
                    const positionEci = positionAndVelocity.position;

                    if (positionEci) {
                        const gmst = satellite.gstime(Cesium.JulianDate.toDate(time));
                        const positionGd = satellite.eciToGeodetic(positionEci, gmst);
                        const longitude = Cesium.Math.toDegrees(positionGd.longitude);
                        const latitude = Cesium.Math.toDegrees(positionGd.latitude);
                        const height = positionGd.height * 1000;

                        positionProperty.addSample(time, Cesium.Cartesian3.fromDegrees(longitude, latitude, height));
                    }
                }

                viewer.entities.add({
                    id: `${type}_${object.name}_${index}`,
                    name: object.name,
                    position: positionProperty,
                    point: {
                        pixelSize: 5,
                        color: color,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 1
                    },
                    tle: object.tle
                });
            });
        }

        fetchAllTLEData().then(({ debrisData, satelliteData }) => {
            addSatellitesAndDebris(debrisData, Cesium.Color.YELLOW, 'debris');
            addSatellitesAndDebris(satelliteData, Cesium.Color.BLUE, 'satellite');

            viewer.clock.startTime = Cesium.JulianDate.now();
            viewer.clock.stopTime = Cesium.JulianDate.addHours(viewer.clock.startTime, 1, new Cesium.JulianDate());
            viewer.clock.currentTime = viewer.clock.startTime;
            viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
            viewer.clock.multiplier = 44;
            viewer.clock.shouldAnimate = true;

            viewer.clock.onTick.addEventListener(detectCollisions);
        });

        const collisionSet = new Set();

        function detectCollisions() {
            const entities = viewer.entities.values;
            const distanceThreshold = 15000;

            for (let i = 0; i < entities.length; i++) {
                const entityA = entities[i];
                const positionA = entityA.position && entityA.position.getValue(viewer.clock.currentTime);

                if (!positionA) continue;

                for (let j = i + 1; j < entities.length; j++) {
                    const entityB = entities[j];
                    const positionB = entityB.position && entityB.position.getValue(viewer.clock.currentTime);

                    if (!positionB) continue;

                    const distance = Cesium.Cartesian3.distance(positionA, positionB);
                    if (distance < distanceThreshold) {
                        if (!collisionSet.has(entityA.id) && !collisionSet.has(entityB.id)) {
                            entityA.point.color = Cesium.Color.LIGHTBLUE;
                            entityB.point.color = Cesium.Color.RED;

                            collisionSet.add(entityA.id);
                            collisionSet.add(entityB.id);
                        }
                    }
                }
            }
        }

        function generateOrbit(entity) {
            console.log("Generating orbit for:", entity.name); // Log the entity being processed

            const positionProperty = entity.position;

            if (positionProperty && positionProperty.getValue(viewer.clock.currentTime)) {
                // Add path to visualize orbit
                entity.path = new Cesium.PathGraphics({
                    material: new Cesium.PolylineGlowMaterialProperty({
                        glowPower: 0.2,
                        color: Cesium.Color.WHITE
                    }),
                    width: 3,
                    leadTime: 3600, // 1 hour into the future
                    trailTime: 3600, // 1 hour into the past
                    resolution: 120
                });

                // Apply glow effect to the selected object
                entity.point.pixelSize = 10;
                entity.point.color = Cesium.Color.WHITE;
                entity.point.outlineColor = Cesium.Color.YELLOW;
                entity.point.outlineWidth = 3;


                // downward path(99/1 chance hai bhai)
                const startTime = viewer.clock.currentTime;
                const deorbitPosition = new Cesium.SampledPositionProperty();
                const heightReductionRate = 35000; // speed

                for (let i = 0; i <= 3600; i += 60) {
                    const time = Cesium.JulianDate.addSeconds(startTime, i, new Cesium.JulianDate());
                    const currentPos = positionProperty.getValue(time);

                    if (currentPos) {
                        const cartographic = Cesium.Cartographic.fromCartesian(currentPos);
                        let height = cartographic.height - (i / 60) * heightReductionRate;

                        if (height < 0) {
                            height = 0; // make sure it reaches surface
                        }

                        deorbitPosition.addSample(time, Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height));
                    }
                }

                entity.position = deorbitPosition;

                // remove entity once on ground
                viewer.clock.onTick.addEventListener(() => {
                    const currentPosition = entity.position.getValue(viewer.clock.currentTime);
                    if (currentPosition) {
                        const cartographic = Cesium.Cartographic.fromCartesian(currentPosition);
                        if (cartographic.height <= 0) {
                            viewer.entities.remove(entity);
                            viewer.clock.onTick.removeEventListener(this); // Remove event listener
                        }
                    }
                });
            }
        }



        viewer.selectedEntityChanged.addEventListener(function (selectedEntity) {
            if (selectedEntity) {
                document.getElementById('object-info').innerText = selectedEntity.name;
            } else {
                document.getElementById("object-info").textContent = "Click on an object to see details.";
            }
        });

        viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(event) {
            const pickedObject = viewer.scene.pick(event.position);
            
            

            if (Cesium.defined(pickedObject) && pickedObject.id) {
                viewer.selectedEntity = pickedObject.id;
                generateOrbit(pickedObject.id);
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        let zoomingIn = false;
        let zoomingOut = false;

        document.getElementById("zoomInBtn").addEventListener("mousedown", function () {
            zoomingIn = true;
            zoomInContinuously();
        });

        document.getElementById("zoomInBtn").addEventListener("mouseup", function () {
            zoomingIn = false;
        });

        document.getElementById("zoomInBtn").addEventListener("mouseleave", function () {
            zoomingIn = false;
        });

        document.getElementById("zoomOutBtn").addEventListener("mousedown", function () {
            zoomingOut = true;
            zoomOutContinuously();
        });

        document.getElementById("zoomOutBtn").addEventListener("mouseup", function () {
            zoomingOut = false;
        });

        document.getElementById("zoomOutBtn").addEventListener("mouseleave", function () {
            zoomingOut = false;
        });

        function zoomInContinuously() {
            if (zoomingIn) {
                viewer.camera.zoomIn(50000);
                requestAnimationFrame(zoomInContinuously);
            }
        }

        function zoomOutContinuously() {
            if (zoomingOut) {
                viewer.camera.zoomOut(50000);
                requestAnimationFrame(zoomOutContinuously);
            }
        }

        document.getElementById("resetBtn").addEventListener("click", function () {
        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(0, 0, 50000000) // reset cam pos
        });
    });
    </script>
</body>

</html>
